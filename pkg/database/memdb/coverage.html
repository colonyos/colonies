
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>memdb: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/colonyos/colonies/pkg/database/memdb/distributed_velocity.go (0.0%)</option>
				
				<option value="file1">github.com/colonyos/colonies/pkg/database/memdb/types.go (0.0%)</option>
				
				<option value="file2">github.com/colonyos/colonies/pkg/database/memdb/velocitydb.go (90.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package memdb

import (
        "context"
        "fmt"
        "net"
        "strconv"
        "sync"
        "time"

        "github.com/colonyos/colonies/pkg/database/memdb/cluster"
        velocityRaft "github.com/colonyos/colonies/pkg/database/memdb/raft"
        "github.com/google/uuid"
        "github.com/hashicorp/raft"
)

// DistributedVelocityDB combines VelocityDB with Raft consensus and cluster membership
type DistributedVelocityDB struct {
        localDB     *VelocityDB
        raftNode    *velocityRaft.RaftNode
        cluster     *cluster.ClusterManager
        config      *DistributedConfig
        nodeID      string
        mu          sync.RWMutex
        readyC      chan struct{}
        isReady     bool
}

// DistributedConfig holds configuration for distributed VelocityDB
type DistributedConfig struct {
        // Local storage config
        DataDir     string
        CacheSize   int
        InMemory    bool

        // Node identity
        NodeName    string
        NodeID      string

        // Raft configuration
        RaftDir     string
        RaftBind    string
        RaftPort    int

        // Memberlist configuration  
        ClusterBind string
        ClusterPort int
        SeedNodes   []string

        // Cluster behavior
        Bootstrap           bool
        WaitForLeaderTimeout time.Duration
        MinClusterSize       int
}

// StorageAdapter adapts VelocityDB to the Raft storage interface
type StorageAdapter struct {
        db *VelocityDB
}

// NewDistributedVelocityDB creates a new distributed VelocityDB instance
func NewDistributedVelocityDB(config *DistributedConfig) (*DistributedVelocityDB, error) <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config cannot be nil")
        }</span>

        // Set defaults
        <span class="cov0" title="0">if config.NodeID == "" </span><span class="cov0" title="0">{
                config.NodeID = uuid.New().String()
        }</span>
        <span class="cov0" title="0">if config.NodeName == "" </span><span class="cov0" title="0">{
                config.NodeName = config.NodeID
        }</span>
        <span class="cov0" title="0">if config.WaitForLeaderTimeout == 0 </span><span class="cov0" title="0">{
                config.WaitForLeaderTimeout = 30 * time.Second
        }</span>
        <span class="cov0" title="0">if config.MinClusterSize == 0 </span><span class="cov0" title="0">{
                config.MinClusterSize = 1
        }</span>

        // Create local VelocityDB
        <span class="cov0" title="0">velocityConfig := &amp;VelocityConfig{
                DataDir:   config.DataDir,
                CacheSize: config.CacheSize,
                InMemory:  config.InMemory,
        }

        localDB, err := NewVelocityDB(velocityConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create local VelocityDB: %w", err)
        }</span>

        // Create storage adapter for Raft
        <span class="cov0" title="0">storageAdapter := &amp;StorageAdapter{db: localDB}

        // Create Raft node
        raftConfig := &amp;velocityRaft.RaftConfig{
                NodeID:            config.NodeID,
                RaftDir:           config.RaftDir,
                RaftBind:          fmt.Sprintf("%s:%d", config.RaftBind, config.RaftPort),
                LocalID:           raft.ServerID(config.NodeName),
                LogLevel:          "WARN",
                SnapshotRetain:    2,
                SnapshotThreshold: 1000,
        }

        raftNode, err := velocityRaft.NewRaftNode(raftConfig, storageAdapter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Raft node: %w", err)
        }</span>

        // Create cluster manager
        <span class="cov0" title="0">clusterConfig := &amp;cluster.ClusterConfig{
                NodeName:  config.NodeName,
                BindAddr:  config.ClusterBind,
                BindPort:  config.ClusterPort,
                RaftAddr:  raftConfig.RaftBind,
                SeedNodes: config.SeedNodes,
                LogOutput: false,
        }

        clusterManager, err := cluster.NewClusterManager(clusterConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create cluster manager: %w", err)
        }</span>

        <span class="cov0" title="0">ddb := &amp;DistributedVelocityDB{
                localDB:  localDB,
                raftNode: raftNode,
                cluster:  clusterManager,
                config:   config,
                nodeID:   config.NodeID,
                readyC:   make(chan struct{}),
        }

        // Start the distributed database
        if err := ddb.start(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to start distributed database: %w", err)
        }</span>

        <span class="cov0" title="0">return ddb, nil</span>
}

// start initializes and starts the distributed database
func (d *DistributedVelocityDB) start() error <span class="cov0" title="0">{
        // Join cluster
        if err := d.cluster.Join(d.config.SeedNodes); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to join cluster: %w", err)
        }</span>

        // Wait for minimum cluster size
        <span class="cov0" title="0">if d.config.MinClusterSize &gt; 1 </span><span class="cov0" title="0">{
                discovery := cluster.NewDiscoveryHelper(d.cluster)
                err := discovery.WaitForMinimumMembers(d.config.MinClusterSize, d.config.WaitForLeaderTimeout)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to reach minimum cluster size: %w", err)
                }</span>
        }

        // Bootstrap or join Raft cluster
        <span class="cov0" title="0">if d.config.Bootstrap </span><span class="cov0" title="0">{
                if err := d.raftNode.Bootstrap(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to bootstrap Raft: %w", err)
                }</span>
        }

        // Wait for Raft leader
        <span class="cov0" title="0">if err := d.raftNode.WaitForLeader(d.config.WaitForLeaderTimeout); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to elect leader: %w", err)
        }</span>

        // Mark as ready
        <span class="cov0" title="0">d.mu.Lock()
        d.isReady = true
        close(d.readyC)
        d.mu.Unlock()

        return nil</span>
}

// WaitForReady waits until the distributed database is ready
func (d *DistributedVelocityDB) WaitForReady(timeout time.Duration) error <span class="cov0" title="0">{
        select </span>{
        case &lt;-d.readyC:<span class="cov0" title="0">
                return nil</span>
        case &lt;-time.After(timeout):<span class="cov0" title="0">
                return fmt.Errorf("timeout waiting for database to become ready")</span>
        }
}

// IsReady returns true if the distributed database is ready
func (d *DistributedVelocityDB) IsReady() bool <span class="cov0" title="0">{
        d.mu.RLock()
        defer d.mu.RUnlock()
        return d.isReady
}</span>

// IsLeader returns true if this node is the Raft leader
func (d *DistributedVelocityDB) IsLeader() bool <span class="cov0" title="0">{
        return d.raftNode.IsLeader()
}</span>

// LeaderAddr returns the address of the current Raft leader
func (d *DistributedVelocityDB) LeaderAddr() string <span class="cov0" title="0">{
        return string(d.raftNode.LeaderAddr())
}</span>

// GetClusterMembers returns all cluster members
func (d *DistributedVelocityDB) GetClusterMembers() []*cluster.ClusterMember <span class="cov0" title="0">{
        return d.cluster.GetMembers()
}</span>

// Insert adds a new document with strong consistency (Raft)
func (d *DistributedVelocityDB) Insert(ctx context.Context, collection string, doc *VelocityDocument) error <span class="cov0" title="0">{
        if !d.IsReady() </span><span class="cov0" title="0">{
                return fmt.Errorf("database not ready")
        }</span>

        <span class="cov0" title="0">entry := &amp;velocityRaft.LogEntry{
                Type:       "insert",
                Collection: collection,
                Key:        doc.ID,
                Value:      doc.Fields,
                Timestamp:  time.Now(),
                RequestID:  uuid.New().String(),
        }

        response, err := d.raftNode.ApplyLog(entry)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply insert: %w", err)
        }</span>

        <span class="cov0" title="0">if !response.Success </span><span class="cov0" title="0">{
                return fmt.Errorf("insert failed: %s", response.Error)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Get retrieves a document with local consistency (fast read)
func (d *DistributedVelocityDB) Get(ctx context.Context, collection string, id string) (*VelocityDocument, error) <span class="cov0" title="0">{
        // Local reads for performance
        return d.localDB.Get(ctx, collection, id)
}</span>

// GetStrong retrieves a document with strong consistency (leader read)
func (d *DistributedVelocityDB) GetStrong(ctx context.Context, collection string, id string) (*VelocityDocument, error) <span class="cov0" title="0">{
        if !d.IsLeader() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("strong reads require leader")
        }</span>
        
        <span class="cov0" title="0">return d.localDB.Get(ctx, collection, id)</span>
}

// Update modifies a document with strong consistency
func (d *DistributedVelocityDB) Update(ctx context.Context, collection string, id string, fields map[string]interface{}) (*VelocityDocument, error) <span class="cov0" title="0">{
        if !d.IsReady() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("database not ready")
        }</span>

        <span class="cov0" title="0">entry := &amp;velocityRaft.LogEntry{
                Type:       "update",
                Collection: collection,
                Key:        id,
                Fields:     fields,
                Timestamp:  time.Now(),
                RequestID:  uuid.New().String(),
        }

        response, err := d.raftNode.ApplyLog(entry)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to apply update: %w", err)
        }</span>

        <span class="cov0" title="0">if !response.Success </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("update failed: %s", response.Error)
        }</span>

        // Return updated document
        <span class="cov0" title="0">return d.localDB.Get(ctx, collection, id)</span>
}

// Delete removes a document with strong consistency
func (d *DistributedVelocityDB) Delete(ctx context.Context, collection string, id string) error <span class="cov0" title="0">{
        if !d.IsReady() </span><span class="cov0" title="0">{
                return fmt.Errorf("database not ready")
        }</span>

        <span class="cov0" title="0">entry := &amp;velocityRaft.LogEntry{
                Type:       "delete",
                Collection: collection,
                Key:        id,
                Timestamp:  time.Now(),
                RequestID:  uuid.New().String(),
        }

        response, err := d.raftNode.ApplyLog(entry)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply delete: %w", err)
        }</span>

        <span class="cov0" title="0">if !response.Success </span><span class="cov0" title="0">{
                return fmt.Errorf("delete failed: %s", response.Error)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CompareAndSwap performs atomic compare-and-swap with strong consistency
func (d *DistributedVelocityDB) CompareAndSwap(ctx context.Context, collection string, cas *VelocityCASRequest) (*VelocityCASResult, error) <span class="cov0" title="0">{
        if !d.IsReady() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("database not ready")
        }</span>

        <span class="cov0" title="0">expectedMap, ok := cas.Expected.(map[string]interface{})
        if !ok &amp;&amp; cas.Expected != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected value must be map[string]interface{} or nil")
        }</span>

        <span class="cov0" title="0">valueMap, ok := cas.Value.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("value must be map[string]interface{}")
        }</span>

        <span class="cov0" title="0">entry := &amp;velocityRaft.LogEntry{
                Type:       "cas",
                Collection: collection,
                Key:        cas.Key,
                Expected:   expectedMap,
                Value:      valueMap,
                Timestamp:  time.Now(),
                RequestID:  uuid.New().String(),
        }

        response, err := d.raftNode.ApplyLog(entry)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to apply CAS: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;VelocityCASResult{
                Success:      response.Success,
                CurrentValue: response.Value,
                Version:      response.Version,
        }, nil</span>
}

// List returns documents with local consistency (fast read)
func (d *DistributedVelocityDB) List(ctx context.Context, collection string, limit, offset int) ([]*VelocityDocument, error) <span class="cov0" title="0">{
        return d.localDB.List(ctx, collection, limit, offset)
}</span>

// Count returns document count with local consistency
func (d *DistributedVelocityDB) Count(ctx context.Context, collection string) (int, error) <span class="cov0" title="0">{
        return d.localDB.Count(ctx, collection)
}</span>

// Health checks the health of the distributed database
func (d *DistributedVelocityDB) Health(ctx context.Context) error <span class="cov0" title="0">{
        if !d.IsReady() </span><span class="cov0" title="0">{
                return fmt.Errorf("database not ready")
        }</span>

        // Check local database
        <span class="cov0" title="0">if err := d.localDB.Health(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("local database unhealthy: %w", err)
        }</span>

        // Check Raft status
        <span class="cov0" title="0">stats := d.raftNode.Stats()
        state, ok := stats["state"]
        if !ok || (state != "Leader" &amp;&amp; state != "Follower") </span><span class="cov0" title="0">{
                return fmt.Errorf("raft node in invalid state: %s", state)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetClusterInfo returns information about the cluster
func (d *DistributedVelocityDB) GetClusterInfo() map[string]interface{} <span class="cov0" title="0">{
        info := make(map[string]interface{})
        
        info["node_id"] = d.nodeID
        info["is_leader"] = d.IsLeader()
        info["leader_addr"] = d.LeaderAddr()
        info["cluster_size"] = d.cluster.NumMembers()
        info["alive_members"] = d.cluster.NumAliveMembers()
        info["raft_stats"] = d.raftNode.Stats()
        
        members := d.cluster.GetMembers()
        memberInfo := make([]map[string]interface{}, len(members))
        for i, member := range members </span><span class="cov0" title="0">{
                memberInfo[i] = map[string]interface{}{
                        "id":        member.ID,
                        "name":      member.Name,
                        "addr":      member.Addr,
                        "port":      member.Port,
                        "raft_addr": member.RaftAddr,
                        "state":     member.State,
                }
        }</span>
        <span class="cov0" title="0">info["members"] = memberInfo
        
        return info</span>
}

// Shutdown gracefully shuts down the distributed database
func (d *DistributedVelocityDB) Shutdown() error <span class="cov0" title="0">{
        var errs []error

        // Shutdown cluster first
        if err := d.cluster.Leave(5 * time.Second); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("cluster leave error: %w", err))
        }</span>

        // Shutdown Raft
        <span class="cov0" title="0">if err := d.raftNode.Shutdown(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("raft shutdown error: %w", err))
        }</span>

        // Close cluster
        <span class="cov0" title="0">if err := d.cluster.Shutdown(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("cluster shutdown error: %w", err))
        }</span>

        // Close local database
        <span class="cov0" title="0">if err := d.localDB.Close(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("local db close error: %w", err))
        }</span>

        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("shutdown errors: %v", errs)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// StorageAdapter implementation

func (s *StorageAdapter) Insert(ctx context.Context, collection string, key string, value map[string]interface{}) error <span class="cov0" title="0">{
        doc := &amp;VelocityDocument{
                ID:     key,
                Fields: value,
        }
        return s.db.Insert(ctx, collection, doc)
}</span>

func (s *StorageAdapter) Update(ctx context.Context, collection string, key string, fields map[string]interface{}) (map[string]interface{}, uint64, error) <span class="cov0" title="0">{
        updated, err := s.db.Update(ctx, collection, key, fields)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">return updated.Fields, updated.Version, nil</span>
}

func (s *StorageAdapter) Delete(ctx context.Context, collection string, key string) error <span class="cov0" title="0">{
        return s.db.Delete(ctx, collection, key)
}</span>

func (s *StorageAdapter) Get(ctx context.Context, collection string, key string) (map[string]interface{}, uint64, error) <span class="cov0" title="0">{
        doc, err := s.db.Get(ctx, collection, key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">return doc.Fields, doc.Version, nil</span>
}

func (s *StorageAdapter) CompareAndSwap(ctx context.Context, collection string, key string, expected, value map[string]interface{}) (bool, map[string]interface{}, uint64, error) <span class="cov0" title="0">{
        cas := &amp;VelocityCASRequest{
                Key:      key,
                Expected: expected,
                Value:    value,
        }

        result, err := s.db.CompareAndSwap(ctx, collection, cas)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, 0, err
        }</span>

        <span class="cov0" title="0">currentMap, ok := result.CurrentValue.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                currentMap = make(map[string]interface{})
        }</span>

        <span class="cov0" title="0">return result.Success, currentMap, result.Version, nil</span>
}

// Helper functions

// parseAddr parses "host:port" and returns host, port
func parseAddr(addr string) (string, int, error) <span class="cov0" title="0">{
        host, portStr, err := net.SplitHostPort(addr)
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, err
        }</span>
        
        <span class="cov0" title="0">port, err := strconv.Atoi(portStr)
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, err
        }</span>
        
        <span class="cov0" title="0">return host, port, nil</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package memdb

import (
        "context"
        "time"
)

// ConsistencyLevel defines the consistency requirements for operations
type ConsistencyLevel int

const (
        Local ConsistencyLevel = iota
        Eventual
        Strong
        Quorum
)

func (c ConsistencyLevel) String() string <span class="cov0" title="0">{
        switch c </span>{
        case Local:<span class="cov0" title="0">
                return "Local"</span>
        case Eventual:<span class="cov0" title="0">
                return "Eventual"</span>
        case Strong:<span class="cov0" title="0">
                return "Strong"</span>
        case Quorum:<span class="cov0" title="0">
                return "Quorum"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}

// StorageMode defines how data is stored and persisted
type StorageMode int

const (
        MemoryOnly StorageMode = iota
        MemoryFirst
        Hybrid
        Persistent
)

func (s StorageMode) String() string <span class="cov0" title="0">{
        switch s </span>{
        case MemoryOnly:<span class="cov0" title="0">
                return "MemoryOnly"</span>
        case MemoryFirst:<span class="cov0" title="0">
                return "MemoryFirst"</span>
        case Hybrid:<span class="cov0" title="0">
                return "Hybrid"</span>
        case Persistent:<span class="cov0" title="0">
                return "Persistent"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}

// CASRequest represents a Compare-And-Swap operation
type CASRequest struct {
        Key      string
        Expected interface{}
        Value    interface{}
        TTL      time.Duration
}

// CASResponse represents the result of a CAS operation
type CASResponse struct {
        Success      bool
        CurrentValue interface{}
        Version      uint64
}

// Document represents a generic document in the database
type Document struct {
        ID       string                 `json:"id"`
        Fields   map[string]interface{} `json:"fields"`
        Version  uint64                 `json:"version"`
        Created  time.Time             `json:"created"`
        Modified time.Time             `json:"modified"`
}

// Query represents a database query
type Query struct {
        Collection string
        Filter     map[string]interface{}
        Sort       []string
        Limit      int
        Offset     int
}

// QueryResult represents query results
type QueryResult struct {
        Documents []*Document
        Total     int
        HasMore   bool
}

// Database is the main interface for MemDB operations
type Database interface {
        // Collection operations
        CreateCollection(ctx context.Context, name string, sch interface{}, consistency ConsistencyLevel) error
        DropCollection(ctx context.Context, name string, consistency ConsistencyLevel) error
        ListCollections(ctx context.Context) ([]string, error)

        // Document operations
        Insert(ctx context.Context, collection string, doc *Document, consistency ConsistencyLevel) error
        Update(ctx context.Context, collection string, id string, fields map[string]interface{}, consistency ConsistencyLevel) (*Document, error)
        Delete(ctx context.Context, collection string, id string, consistency ConsistencyLevel) error
        Get(ctx context.Context, collection string, id string, consistency ConsistencyLevel) (*Document, error)
        
        // Query operations
        Query(ctx context.Context, query *Query, consistency ConsistencyLevel) (*QueryResult, error)
        Count(ctx context.Context, collection string, filter map[string]interface{}, consistency ConsistencyLevel) (int, error)

        // CAS operations
        CompareAndSwap(ctx context.Context, collection string, cas *CASRequest, consistency ConsistencyLevel) (*CASResponse, error)

        // Batch operations
        Batch(ctx context.Context, ops []BatchOperation, consistency ConsistencyLevel) error

        // Health and status
        Health(ctx context.Context) error
        Stats(ctx context.Context) (*DatabaseStats, error)

        // Lifecycle
        Close() error
}

// BatchOperation represents a single operation in a batch
type BatchOperation struct {
        Type       string      // "insert", "update", "delete"
        Collection string
        Document   *Document
        ID         string
        Fields     map[string]interface{}
}

// DatabaseStats provides database statistics
type DatabaseStats struct {
        Collections int64
        Documents   int64
        MemoryUsage int64
        DiskUsage   int64
        Uptime      time.Duration
}</pre>
		
		<pre class="file" id="file2" style="display: none">package memdb

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/coocood/freecache"
        "github.com/dgraph-io/badger/v4"
        "github.com/google/uuid"
)

// VelocityDB is a complete, working in-memory database
type VelocityDB struct {
        db    *badger.DB
        cache *freecache.Cache
        mu    sync.RWMutex
}

// VelocityConfig holds configuration
type VelocityConfig struct {
        DataDir   string
        CacheSize int  // MB
        InMemory  bool
}

// VelocityDocument represents a document
type VelocityDocument struct {
        ID       string                 `json:"id"`
        Fields   map[string]interface{} `json:"fields"`
        Version  uint64                 `json:"version"`
        Created  time.Time             `json:"created"`
        Modified time.Time             `json:"modified"`
}

// CASRequest for compare-and-swap
type VelocityCASRequest struct {
        Key      string
        Expected interface{}
        Value    interface{}
}

// CASResult for compare-and-swap response
type VelocityCASResult struct {
        Success      bool
        CurrentValue interface{}
        Version      uint64
}

// NewVelocityDB creates a new VelocityDB instance
func NewVelocityDB(config *VelocityConfig) (*VelocityDB, error) <span class="cov8" title="1">{
        if config == nil </span><span class="cov0" title="0">{
                config = &amp;VelocityConfig{
                        DataDir:   "/tmp/velocitydb",
                        CacheSize: 100,
                        InMemory:  true,
                }
        }</span>

        <span class="cov8" title="1">var opts badger.Options
        if config.InMemory </span><span class="cov8" title="1">{
                opts = badger.DefaultOptions("").WithInMemory(true).WithLogger(nil)
        }</span> else<span class="cov8" title="1"> {
                opts = badger.DefaultOptions(config.DataDir).WithLogger(nil)
        }</span>

        <span class="cov8" title="1">db, err := badger.Open(opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open BadgerDB: %w", err)
        }</span>

        <span class="cov8" title="1">cache := freecache.NewCache(config.CacheSize * 1024 * 1024)

        return &amp;VelocityDB{
                db:    db,
                cache: cache,
        }, nil</span>
}

// Insert adds a new document
func (v *VelocityDB) Insert(ctx context.Context, collection string, doc *VelocityDocument) error <span class="cov8" title="1">{
        v.mu.Lock()
        defer v.mu.Unlock()

        if doc.ID == "" </span><span class="cov0" title="0">{
                doc.ID = uuid.New().String()
        }</span>

        <span class="cov8" title="1">doc.Version = 1
        doc.Created = time.Now()
        doc.Modified = doc.Created

        key := v.key(collection, doc.ID)
        data, err := json.Marshal(doc)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal document: %w", err)
        }</span>

        <span class="cov8" title="1">err = v.db.Update(func(txn *badger.Txn) error </span><span class="cov8" title="1">{
                // Check if exists
                _, err := txn.Get([]byte(key))
                if err == nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("document already exists")
                }</span>
                
                <span class="cov8" title="1">return txn.Set([]byte(key), data)</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Cache it
        <span class="cov8" title="1">v.cache.Set([]byte(key), data, 0)
        return nil</span>
}

// Get retrieves a document
func (v *VelocityDB) Get(ctx context.Context, collection string, id string) (*VelocityDocument, error) <span class="cov8" title="1">{
        key := v.key(collection, id)

        // Try cache first
        if cached, err := v.cache.Get([]byte(key)); err == nil </span><span class="cov8" title="1">{
                var doc VelocityDocument
                if err := json.Unmarshal(cached, &amp;doc); err == nil </span><span class="cov8" title="1">{
                        return &amp;doc, nil
                }</span>
        }

        // Fallback to BadgerDB
        <span class="cov8" title="1">var doc VelocityDocument
        err := v.db.View(func(txn *badger.Txn) error </span><span class="cov8" title="1">{
                item, err := txn.Get([]byte(key))
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">return item.Value(func(val []byte) error </span><span class="cov8" title="1">{
                        return json.Unmarshal(val, &amp;doc)
                }</span>)
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                if err == badger.ErrKeyNotFound </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("document not found")
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // Cache it
        <span class="cov8" title="1">if data, err := json.Marshal(doc); err == nil </span><span class="cov8" title="1">{
                v.cache.Set([]byte(key), data, 0)
        }</span>

        <span class="cov8" title="1">return &amp;doc, nil</span>
}

// Update modifies a document
func (v *VelocityDB) Update(ctx context.Context, collection string, id string, fields map[string]interface{}) (*VelocityDocument, error) <span class="cov8" title="1">{
        v.mu.Lock()
        defer v.mu.Unlock()

        key := v.key(collection, id)
        var updatedDoc *VelocityDocument

        err := v.db.Update(func(txn *badger.Txn) error </span><span class="cov8" title="1">{
                item, err := txn.Get([]byte(key))
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("document not found")
                }</span>

                <span class="cov8" title="1">var doc VelocityDocument
                err = item.Value(func(val []byte) error </span><span class="cov8" title="1">{
                        return json.Unmarshal(val, &amp;doc)
                }</span>)
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Update fields
                <span class="cov8" title="1">if doc.Fields == nil </span><span class="cov0" title="0">{
                        doc.Fields = make(map[string]interface{})
                }</span>
                <span class="cov8" title="1">for k, v := range fields </span><span class="cov8" title="1">{
                        doc.Fields[k] = v
                }</span>

                <span class="cov8" title="1">doc.Version++
                doc.Modified = time.Now()

                data, err := json.Marshal(doc)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">updatedDoc = &amp;doc
                return txn.Set([]byte(key), data)</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Update cache
        <span class="cov8" title="1">if data, err := json.Marshal(updatedDoc); err == nil </span><span class="cov8" title="1">{
                v.cache.Set([]byte(key), data, 0)
        }</span>

        <span class="cov8" title="1">return updatedDoc, nil</span>
}

// Delete removes a document
func (v *VelocityDB) Delete(ctx context.Context, collection string, id string) error <span class="cov8" title="1">{
        v.mu.Lock()
        defer v.mu.Unlock()

        key := v.key(collection, id)

        err := v.db.Update(func(txn *badger.Txn) error </span><span class="cov8" title="1">{
                _, err := txn.Get([]byte(key))
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("document not found")
                }</span>
                <span class="cov8" title="1">return txn.Delete([]byte(key))</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">v.cache.Del([]byte(key))
        return nil</span>
}

// List returns all documents in a collection
func (v *VelocityDB) List(ctx context.Context, collection string, limit, offset int) ([]*VelocityDocument, error) <span class="cov8" title="1">{
        prefix := v.prefix(collection)
        var documents []*VelocityDocument

        err := v.db.View(func(txn *badger.Txn) error </span><span class="cov8" title="1">{
                opts := badger.DefaultIteratorOptions
                it := txn.NewIterator(opts)
                defer it.Close()

                count := 0
                skipped := 0

                for it.Seek([]byte(prefix)); it.Valid(); it.Next() </span><span class="cov8" title="1">{
                        key := it.Item().Key()
                        if !strings.HasPrefix(string(key), prefix) </span><span class="cov0" title="0">{
                                break</span>
                        }

                        <span class="cov8" title="1">if skipped &lt; offset </span><span class="cov8" title="1">{
                                skipped++
                                continue</span>
                        }

                        <span class="cov8" title="1">if limit &gt; 0 &amp;&amp; count &gt;= limit </span><span class="cov8" title="1">{
                                break</span>
                        }

                        <span class="cov8" title="1">var doc VelocityDocument
                        err := it.Item().Value(func(val []byte) error </span><span class="cov8" title="1">{
                                return json.Unmarshal(val, &amp;doc)
                        }</span>)
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">documents = append(documents, &amp;doc)
                        count++</span>
                }

                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">return documents, err</span>
}

// Count returns the number of documents in a collection
func (v *VelocityDB) Count(ctx context.Context, collection string) (int, error) <span class="cov8" title="1">{
        prefix := v.prefix(collection)
        count := 0

        err := v.db.View(func(txn *badger.Txn) error </span><span class="cov8" title="1">{
                opts := badger.DefaultIteratorOptions
                opts.PrefetchValues = false
                it := txn.NewIterator(opts)
                defer it.Close()

                for it.Seek([]byte(prefix)); it.Valid(); it.Next() </span><span class="cov8" title="1">{
                        key := it.Item().Key()
                        if !strings.HasPrefix(string(key), prefix) </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov8" title="1">count++</span>
                }

                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">return count, err</span>
}

// CompareAndSwap performs atomic compare-and-swap
func (v *VelocityDB) CompareAndSwap(ctx context.Context, collection string, cas *VelocityCASRequest) (*VelocityCASResult, error) <span class="cov8" title="1">{
        v.mu.Lock()
        defer v.mu.Unlock()

        key := v.key(collection, cas.Key)
        var result *VelocityCASResult

        err := v.db.Update(func(txn *badger.Txn) error </span><span class="cov8" title="1">{
                // Get current document
                item, err := txn.Get([]byte(key))
                if err != nil &amp;&amp; err != badger.ErrKeyNotFound </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">var currentDoc *VelocityDocument
                if err != badger.ErrKeyNotFound </span><span class="cov8" title="1">{
                        currentDoc = &amp;VelocityDocument{}
                        err = item.Value(func(val []byte) error </span><span class="cov8" title="1">{
                                return json.Unmarshal(val, currentDoc)
                        }</span>)
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // Compare expected with current
                <span class="cov8" title="1">var currentValue interface{}
                if currentDoc != nil </span><span class="cov8" title="1">{
                        currentValue = currentDoc.Fields
                }</span>

                <span class="cov8" title="1">if !v.valuesEqual(cas.Expected, currentValue) </span><span class="cov8" title="1">{
                        result = &amp;VelocityCASResult{
                                Success:      false,
                                CurrentValue: currentValue,
                                Version:      0,
                        }
                        if currentDoc != nil </span><span class="cov8" title="1">{
                                result.Version = currentDoc.Version
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                }

                // Perform swap
                <span class="cov8" title="1">newFields, ok := cas.Value.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("value must be a map[string]interface{}")
                }</span>

                <span class="cov8" title="1">newDoc := &amp;VelocityDocument{
                        ID:      cas.Key,
                        Fields:  newFields,
                        Version: 1,
                }

                if currentDoc != nil </span><span class="cov8" title="1">{
                        newDoc.Version = currentDoc.Version + 1
                        newDoc.Created = currentDoc.Created
                }</span> else<span class="cov8" title="1"> {
                        newDoc.Created = time.Now()
                }</span>
                <span class="cov8" title="1">newDoc.Modified = time.Now()

                data, err := json.Marshal(newDoc)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">err = txn.Set([]byte(key), data)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">result = &amp;VelocityCASResult{
                        Success:      true,
                        CurrentValue: newDoc.Fields,
                        Version:      newDoc.Version,
                }

                // Update cache
                v.cache.Set([]byte(key), data, 0)

                return nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// Health checks database health
func (v *VelocityDB) Health(ctx context.Context) error <span class="cov8" title="1">{
        // Simple health check
        return v.db.View(func(txn *badger.Txn) error </span><span class="cov8" title="1">{
                return nil
        }</span>)
}

// Close closes the database
func (v *VelocityDB) Close() error <span class="cov8" title="1">{
        return v.db.Close()
}</span>

// Helper methods
func (v *VelocityDB) key(collection, id string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:%s", collection, id)
}</span>

func (v *VelocityDB) prefix(collection string) string <span class="cov8" title="1">{
        return collection + ":"
}</span>

func (v *VelocityDB) valuesEqual(expected, actual interface{}) bool <span class="cov8" title="1">{
        if expected == nil &amp;&amp; actual == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if expected == nil || actual == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // Simple comparison - could be enhanced
        <span class="cov8" title="1">expectedJSON, _ := json.Marshal(expected)
        actualJSON, _ := json.Marshal(actual)
        return string(expectedJSON) == string(actualJSON)</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
