package memdb

import (
	"context"
	"fmt"
	"time"

	"github.com/colonyos/colonies/pkg/database/memdb/consistency"
	"github.com/colonyos/colonies/pkg/database/memdb/core"
	"github.com/colonyos/colonies/pkg/database/memdb/schema"
	"github.com/colonyos/colonies/pkg/database/memdb/storage"
)

// MemDB is the main database interface
type MemDB struct {
	router    *consistency.DatabaseRouter
	casEngine *core.CASEngine
	config    *Config
	storage   *storage.BadgerStorage
}

// Config holds MemDB configuration
type Config struct {
	DataDir           string
	StorageMode       StorageMode
	DefaultConsistency ConsistencyLevel
	CacheSize         int // MB
	ReplicationFactor int
	QuorumSize        int
	SyncWrites        bool
	TTL               time.Duration
}

// NewMemDB creates a new MemDB instance
func NewMemDB(config *Config) (*MemDB, error) {
	if config == nil {
		config = &Config{
			DataDir:           "/tmp/memdb",
			StorageMode:       MemoryFirst,
			DefaultConsistency: Local,
			CacheSize:         100,
			ReplicationFactor: 3,
			QuorumSize:        2,
			SyncWrites:        false,
			TTL:               0, // No TTL by default
		}
	}

	// Create BadgerDB storage
	badgerConfig := &storage.BadgerConfig{
		DataDir:   config.DataDir,
		CacheSize: config.CacheSize,
		SyncWrites: config.SyncWrites,
		InMemory:  config.StorageMode == MemoryOnly,
		TTL:       config.TTL,
	}

	badgerStorage, err := storage.NewBadgerStorage(badgerConfig)
	if err != nil {
		return nil, fmt.Errorf("failed to create storage: %w", err)
	}

	// Create CAS engine
	casEngine := core.NewCASEngine(badgerStorage)

	// Create consistency router
	routerConfig := &consistency.RouterConfig{
		DefaultConsistency: consistency.ConsistencyLevel(config.DefaultConsistency),
		QuorumSize:        config.QuorumSize,
		ReplicationFactor: config.ReplicationFactor,
		EventualSyncDelay: 100 * time.Millisecond,
	}

	// For now, use badgerStorage for all consistency levels
	// In a full implementation, different backends would be used
	router := consistency.NewDatabaseRouter(
		routerConfig,
		badgerStorage, // local
		nil,           // raft (not implemented yet)
		nil,           // quorum (not implemented yet)
		badgerStorage, // eventual
	)

	return &MemDB{
		router:    router,
		casEngine: casEngine,
		config:    config,
		storage:   badgerStorage,
	}, nil
}

// CreateCollection creates a new collection with schema
func (m *MemDB) CreateCollection(ctx context.Context, name string, sch interface{}, consistency ConsistencyLevel) error {
	schemaObj, ok := sch.(*schema.Schema)
	if !ok {
		return fmt.Errorf("invalid schema type")
	}
	return m.router.CreateCollection(ctx, name, schemaObj, consistency.ConsistencyLevel(consistency))
}

// DropCollection removes a collection and all its documents
func (m *MemDB) DropCollection(ctx context.Context, name string, consistency ConsistencyLevel) error {
	return m.storage.DropCollection(ctx, name)
}

// ListCollections returns all collection names
func (m *MemDB) ListCollections(ctx context.Context) ([]string, error) {
	// This would need to be implemented in the storage layer
	return []string{}, fmt.Errorf("ListCollections not yet implemented")
}

// Insert adds a new document to a collection
func (m *MemDB) Insert(ctx context.Context, collection string, doc *Document, consistency ConsistencyLevel) error {
	coreDoc := &core.Document{
		ID:       doc.ID,
		Fields:   doc.Fields,
		Version:  doc.Version,
		Created:  doc.Created,
		Modified: doc.Modified,
	}
	
	return m.router.Insert(ctx, collection, coreDoc, consistency.ConsistencyLevel(consistency))
}

// Update modifies an existing document
func (m *MemDB) Update(ctx context.Context, collection string, id string, fields map[string]interface{}, consistency ConsistencyLevel) (*Document, error) {
	coreDoc, err := m.router.Update(ctx, collection, id, fields, consistency.ConsistencyLevel(consistency))
	if err != nil {
		return nil, err
	}

	return &Document{
		ID:       coreDoc.ID,
		Fields:   coreDoc.Fields,
		Version:  coreDoc.Version,
		Created:  coreDoc.Created,
		Modified: coreDoc.Modified,
	}, nil
}

// Delete removes a document from a collection
func (m *MemDB) Delete(ctx context.Context, collection string, id string, consistency ConsistencyLevel) error {
	return m.router.Delete(ctx, collection, id, consistency.ConsistencyLevel(consistency))
}

// Get retrieves a document by ID
func (m *MemDB) Get(ctx context.Context, collection string, id string, consistency ConsistencyLevel) (*Document, error) {
	coreDoc, err := m.router.Get(ctx, collection, id, consistency.ConsistencyLevel(consistency))
	if err != nil {
		return nil, err
	}

	return &Document{
		ID:       coreDoc.ID,
		Fields:   coreDoc.Fields,
		Version:  coreDoc.Version,
		Created:  coreDoc.Created,
		Modified: coreDoc.Modified,
	}, nil
}

// Query queries documents matching the criteria
func (m *MemDB) Query(ctx context.Context, query *Query, consistency ConsistencyLevel) (*QueryResult, error) {
	docs, err := m.router.Query(ctx, query.Collection, query.Filter, query.Limit, query.Offset, consistency.ConsistencyLevel(consistency))
	if err != nil {
		return nil, err
	}

	// Convert core documents to MemDB documents
	result := &QueryResult{
		Documents: make([]*Document, len(docs)),
		Total:     len(docs),
		HasMore:   false, // This would need proper pagination logic
	}

	for i, doc := range docs {
		result.Documents[i] = &Document{
			ID:       doc.ID,
			Fields:   doc.Fields,
			Version:  doc.Version,
			Created:  doc.Created,
			Modified: doc.Modified,
		}
	}

	return result, nil
}

// Count returns the number of documents matching the filter
func (m *MemDB) Count(ctx context.Context, collection string, filter map[string]interface{}, consistency ConsistencyLevel) (int, error) {
	// This would need to be implemented with proper filtering
	return m.storage.Count(ctx, collection)
}

// CompareAndSwap performs a compare-and-swap operation
func (m *MemDB) CompareAndSwap(ctx context.Context, collection string, cas *CASRequest, consistency ConsistencyLevel) (*CASResponse, error) {
	operation := &core.CASOperation{
		Collection: collection,
		ID:         cas.Key,
		Expected:   cas.Expected,
		Value:      cas.Value,
		TTL:        cas.TTL,
	}

	result, err := m.casEngine.CompareAndSwap(ctx, operation)
	if err != nil {
		return nil, err
	}

	return &CASResponse{
		Success:      result.Success,
		CurrentValue: result.CurrentValue,
		Version:      result.Version,
	}, nil
}

// Batch executes multiple operations atomically
func (m *MemDB) Batch(ctx context.Context, ops []BatchOperation, consistency ConsistencyLevel) error {
	// This would need proper transaction support
	for _, op := range ops {
		switch op.Type {
		case "insert":
			if err := m.Insert(ctx, op.Collection, op.Document, consistency); err != nil {
				return fmt.Errorf("batch insert failed: %w", err)
			}
		case "update":
			if _, err := m.Update(ctx, op.Collection, op.ID, op.Fields, consistency); err != nil {
				return fmt.Errorf("batch update failed: %w", err)
			}
		case "delete":
			if err := m.Delete(ctx, op.Collection, op.ID, consistency); err != nil {
				return fmt.Errorf("batch delete failed: %w", err)
			}
		default:
			return fmt.Errorf("unsupported batch operation: %s", op.Type)
		}
	}
	
	return nil
}

// Health checks the health of the database
func (m *MemDB) Health(ctx context.Context) error {
	// Basic health check - try to access storage
	_, err := m.storage.Count(ctx, "_health_check")
	if err != nil && err.Error() != "document not found" {
		return err
	}
	return nil
}

// Stats returns database statistics
func (m *MemDB) Stats(ctx context.Context) (*DatabaseStats, error) {
	// This would collect real statistics from storage
	return &DatabaseStats{
		Collections: 0, // Would be counted from storage
		Documents:   0, // Would be counted from storage
		MemoryUsage: 0, // Would be gathered from storage
		DiskUsage:   0, // Would be gathered from storage
		Uptime:      time.Since(time.Now()), // Would track actual uptime
	}, nil
}

// Close closes the database
func (m *MemDB) Close() error {
	if m.router != nil {
		if err := m.router.Close(); err != nil {
			return fmt.Errorf("failed to close router: %w", err)
		}
	}
	
	if m.storage != nil {
		if err := m.storage.Close(); err != nil {
			return fmt.Errorf("failed to close storage: %w", err)
		}
	}
	
	return nil
}

// GetVersion returns the database version
func (m *MemDB) GetVersion() string {
	return "1.0.0"
}

// GetConfig returns the current configuration
func (m *MemDB) GetConfig() *Config {
	return m.config
}